{-|
Module      : Language.Lean.Internal.Exception
Copyright   : (c) Galois Inc, 2015
License     : Apache-2
Maintainer  : jhendrix@galois.com, lcasburn@galois.com

Internal operations for working with Lean exceptions.
-}
{-# LANGUAGE DoAndIfThenElse #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE ForeignFunctionInterface #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE Trustworthy #-}
{-# OPTIONS_HADDOCK not-home #-}
module Language.Lean.Internal.Exception
  ( LeanException
  , LeanExceptionKind(..)
  , leanExceptionKind
  , leanExceptionMessage
  , leanExceptionDetailedMessage
  , leanException
    -- * FFI types
  , ExceptionPtr
  , OutExceptionPtr
  , mkLeanException
    -- * Partial operations
  , LeanPartialAction
  , runLeanPartialAction
  , LeanPartialFn
  , runLeanPartialFn
  , runLeanMaybeFn
  , IsLeanValue(..)
    -- * Functions that return a result in IO
  , tryAllocLeanValue
  ) where

import Control.Exception
import Control.Monad (when)
import Data.Typeable
import Foreign
import Foreign.C
import System.IO.Unsafe

import Language.Lean.Internal.String

#include "lean_macros.h"
#include "lean_exception.h"

------------------------------------------------------------------------
-- IsLeanValue

-- | Typeclass that associates Haskell types with their type in the FFI layer.
class Storable p => IsLeanValue v p | v -> p where
  -- | Create a Haskell value from a FFI value.
  mkLeanValue :: p -> IO v

instance IsLeanValue Bool CInt where
  mkLeanValue = return . toEnum . fromIntegral

instance IsLeanValue Word32 CUInt where
  mkLeanValue (CUInt x) = return x

instance IsLeanValue Int32 CInt where
  mkLeanValue (CInt x) = return x

instance IsLeanValue Double CDouble where
  mkLeanValue (CDouble d) = return d

instance IsLeanValue String CString where
  mkLeanValue = getLeanString

------------------------------------------------------------------------
-- LeanExceptionKind

-- | Information about the Kind of exception thrown.
data LeanExceptionKind
   = LeanSystemException
     -- ^ Exception generated by the C++ runtime
   | LeanOutOfMemory
   | LeanInterrupted
   | LeanKernelException
   | LeanUnifierException
   | LeanTacticException
   | LeanParserException
   | LeanOtherException
  deriving (Show)

{#enum lean_exception_kind as ExceptionKind { upcaseFirstLetter }
         deriving (Eq)#}

getLeanExceptionKind :: ExceptionKind -> LeanExceptionKind
getLeanExceptionKind k = do
  case k of
    LEAN_NULL_EXCEPTION   -> error "getLeanException not given an exception"
    LEAN_SYSTEM_EXCEPTION -> LeanSystemException
    LEAN_OUT_OF_MEMORY    -> LeanOutOfMemory
    LEAN_INTERRUPTED      -> LeanInterrupted
    LEAN_KERNEL_EXCEPTION  -> LeanKernelException
    LEAN_UNIFIER_EXCEPTION -> LeanUnifierException
    LEAN_TACTIC_EXCEPTION  -> LeanTacticException
    LEAN_PARSER_EXCEPTION  -> LeanParserException
    LEAN_OTHER_EXCEPTION  -> LeanOtherException

------------------------------------------------------------------------
-- FFI Declarations

-- | An exception thrown by Lean
data LeanException
   = BindingsLeanException !LeanExceptionKind !String
     -- ^ This is an exception generated by the bindings.
   | RealLeanException !(ForeignPtr LeanException)
     -- ^ This is an exception geneerated by Lean
 deriving (Typeable)

instance Show LeanException where
  show e =
    "leanException " ++ show (leanExceptionKind e)
              ++ " " ++ show (leanExceptionDetailedMessage e)

instance Exception LeanException

-- | Create a Lean exception with the given kind and message.
leanException :: LeanExceptionKind -> String -> LeanException
leanException = BindingsLeanException

-- | Pointer used as input parameter for exceptions in FFI bindings
{#pointer lean_exception as ExceptionPtr -> LeanException#}
-- | Pointer used as output parameter for exceptions in FFI bindings
{#pointer *lean_exception as OutExceptionPtr -> ExceptionPtr #}

foreign import ccall unsafe "&lean_exception_del"
  lean_exception_del_ptr :: FunPtr (ExceptionPtr -> IO ())

-- | Create a Lean exception from a pointer.
mkLeanException :: Ptr LeanException -> IO LeanException
mkLeanException = fmap RealLeanException . newForeignPtr lean_exception_del_ptr

instance IsLeanValue LeanException (Ptr LeanException) where
  mkLeanValue = mkLeanException

-- | Get the kind of this exception.
leanExceptionKind :: LeanException -> LeanExceptionKind
leanExceptionKind (BindingsLeanException k _) = k
leanExceptionKind (RealLeanException fnPtr) = seq fnPtr $
  getLeanExceptionKind $
    unsafePerformIO $
      withForeignPtr fnPtr $ lean_exception_get_kind

{#fun unsafe lean_exception_get_kind
 { `ExceptionPtr' } -> `ExceptionKind' #}

-- | Get basic information describing this exception.
leanExceptionMessage :: LeanException -> String
leanExceptionMessage (BindingsLeanException _ msg) = msg
leanExceptionMessage (RealLeanException fnPtr) = seq fnPtr $
  unsafePerformIO $ do
    withForeignPtr fnPtr $ lean_exception_get_message

{#fun unsafe lean_exception_get_message
 { `ExceptionPtr' } -> `String' getLeanString* #}

-- | Get detailed information describing this exception.
leanExceptionDetailedMessage :: LeanException -> String
leanExceptionDetailedMessage (BindingsLeanException _ msg) = msg
leanExceptionDetailedMessage (RealLeanException fnPtr) = seq fnPtr $
  unsafePerformIO $ do
    withForeignPtr fnPtr $ lean_exception_get_detailed_message

{#fun unsafe lean_exception_get_detailed_message
 { `ExceptionPtr' } -> `String' getLeanString* #}

------------------------------------------------------------------------
-- Partial functions

-- | A lean partial function is an action that may fail
type LeanPartialAction = (Ptr ExceptionPtr -> IO Bool)

-- | Run a lean partial action, throwing an exception if it fails.
runLeanPartialAction :: LeanPartialAction -> IO ()
runLeanPartialAction action =
  alloca $ \ex_ptr -> do
    poke ex_ptr nullPtr
    success <- action ex_ptr
    when (not success) $ do
      throwIO =<< mkLeanException =<< peek ex_ptr
{-# INLINE runLeanPartialAction #-}

-- | A lean partial function is a function that returns a value of type @a@, but
-- may fail.
type LeanPartialFn a = (Ptr a -> LeanPartialAction)

-- | Run a lean partial function
runLeanPartialFn :: Storable a
                 => LeanPartialFn a
                 -> IO a
runLeanPartialFn alloc_fn =
  alloca $ \ret_ptr -> do
    runLeanPartialAction (alloc_fn ret_ptr)
    peek ret_ptr
{-# INLINE runLeanPartialFn #-}

-- | Run a lean partial function where false does not automatically imply
-- an exception was thrown.
runLeanMaybeFn :: Storable p
               => LeanPartialFn p
               -> IO (Maybe p)
runLeanMaybeFn alloc_fn =
  alloca $ \ret_ptr -> do
    alloca $ \ex_ptr -> do
      poke ex_ptr nullPtr
      success <- alloc_fn ret_ptr ex_ptr
      if success then do
        r <- peek ret_ptr
        return $! Just r
      else do
        ptr <- peek ex_ptr
        if ptr == nullPtr then
          return $! Nothing
        else
          throwIO =<< mkLeanException ptr
{-# INLINE runLeanMaybeFn #-}

-- | Try to run a Lean partial function that returns a Lean value
-- that will need to be freed.
tryAllocLeanValue :: IsLeanValue a p
                  => LeanPartialFn p
                  -> IO a
tryAllocLeanValue = \alloc_fn -> mkLeanValue =<< runLeanPartialFn alloc_fn
{-# INLINE tryAllocLeanValue #-}
